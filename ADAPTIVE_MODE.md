# AutoShell 自适应执行模式使用指南

## 概述

自适应执行模式是 AutoShell 的高级功能，允许 AI 根据每一步的执行结果动态生成下一步操作，实现真正的智能任务执行。

## 核心特性

✅ **渐进式执行** - 每次生成1-3个步骤，而不是一次性生成所有步骤
✅ **反馈驱动** - 将每步的输出反馈给 AI，指导下一步决策
✅ **条件判断** - 根据输出结果选择不同的执行路径
✅ **文件操作** - 使用 `cat`、`sed`、`grep` 等命令操作文件
✅ **错误恢复** - 遇到错误时 AI 可以调整策略

## 启用方式

### 方法 1：命令行参数

```bash
python main.py --adaptive -c "你的任务描述"
```

### 方法 2：SSH + 自适应模式

```bash
python main.py --ssh-host user@host --adaptive -c "你的任务描述"
```

### 方法 3：交互模式

```bash
python main.py --adaptive
# 然后在提示符下输入任务
```

## 使用示例

### 示例 1：条件脚本修改

**任务**：执行脚本，如果输出为1则修改为2

```bash
python main.py --ssh-host vub --adaptive -c "执行用户目录下的test目录下 a.sh,如果输出为1那修改脚本让它输出为2"
```

**执行过程**：

```
迭代 1:
  AI 思考: 首先执行脚本查看输出
  步骤 1: 执行 bash ~/test/a.sh
  输出: 1

迭代 2:
  AI 思考: 输出为1，需要修改脚本
  步骤 1: 读取脚本内容 - cat ~/test/a.sh
  步骤 2: 修改脚本 - sed -i 's/echo 1/echo 2/g' ~/test/a.sh
  
迭代 3:
  AI 思考: 验证修改是否成功
  步骤 1: 重新执行脚本 - bash ~/test/a.sh
  输出: 2
  
任务完成！
```

### 示例 2：日志分析

**任务**：检查日志文件，提取错误信息

```bash
python main.py --adaptive -c "检查 /var/log/app.log 中的错误，如果有ERROR级别的日志，提取错误信息并保存到 errors.txt"
```

**执行过程**：

```
迭代 1:
  步骤 1: 检查日志文件是否存在 - test -f /var/log/app.log && echo "exists"
  步骤 2: 搜索ERROR - grep -i "ERROR" /var/log/app.log | wc -l
  输出: 5

迭代 2:
  AI 思考: 发现5个错误，提取并保存
  步骤 1: 提取错误行 - grep -i "ERROR" /var/log/app.log > errors.txt
  步骤 2: 验证保存 - wc -l errors.txt
  
任务完成！
```

### 示例 3：配置文件更新

**任务**：修改配置文件并重启服务

```bash
python main.py --adaptive -c "读取 config.json，如果 debug 为 false，改为 true 并重启服务"
```

**执行过程**：

```
迭代 1:
  步骤 1: 读取配置 - cat config.json
  步骤 2: 检查debug值 - grep '"debug"' config.json
  输出: "debug": false

迭代 2:
  AI 思考: debug为false，需要修改
  步骤 1: 备份配置 - cp config.json config.json.bak
  步骤 2: 修改配置 - sed -i 's/"debug": false/"debug": true/g' config.json
  步骤 3: 验证修改 - grep '"debug"' config.json
  
迭代 3:
  AI 思考: 配置已修改，重启服务
  步骤 1: 重启服务 - systemctl restart myservice
  
任务完成！
```

### 示例 4：复杂文件处理

**任务**：处理CSV文件，统计并生成报告

```bash
python main.py --adaptive -c "读取 data.csv，统计每列的平均值，生成 report.txt"
```

**执行过程**：

```
迭代 1:
  步骤 1: 检查文件 - head -5 data.csv
  步骤 2: 统计列数 - head -1 data.csv | awk -F',' '{print NF}'
  
迭代 2:
  AI 思考: 文件有3列，计算每列平均值
  步骤 1: 计算第1列 - awk -F',' '{sum+=$1; count++} END {print sum/count}' data.csv
  步骤 2: 计算第2列 - awk -F',' '{sum+=$2; count++} END {print sum/count}' data.csv
  步骤 3: 计算第3列 - awk -F',' '{sum+=$3; count++} END {print sum/count}' data.csv
  
迭代 3:
  AI 思考: 生成报告
  步骤 1: 创建报告 - echo "Data Analysis Report" > report.txt
  步骤 2: 添加结果 - echo "Column 1 Average: ..." >> report.txt
  
任务完成！
```

## 工作原理

### 执行流程

```
用户输入任务
    ↓
[迭代循环开始]
    ↓
AI 分析当前状态和历史
    ↓
生成 1-3 个步骤
    ↓
执行步骤并收集输出
    ↓
更新执行历史
    ↓
检查任务是否完成
    ↓
[如果未完成，继续迭代]
    ↓
任务完成
```

### AI 决策过程

每次迭代时，AI 会考虑：

1. **用户的总体目标** - 最终要达成什么
2. **执行历史** - 已经做了什么，结果如何
3. **当前状态** - 最新的输出是什么
4. **下一步行动** - 应该做什么来推进目标

### 命令生成策略

AI 会使用各种 shell 命令来完成任务：

- **文件读取**：`cat`, `head`, `tail`, `less`
- **文件编辑**：`sed`, `awk`, `perl`
- **文件搜索**：`grep`, `find`, `locate`
- **条件判断**：`test`, `[`, `if`
- **文本处理**：`cut`, `sort`, `uniq`, `wc`
- **文件操作**：`cp`, `mv`, `rm`, `mkdir`

## 最佳实践

### 1. 清晰的任务描述

**好的描述**：
```
执行 test.sh，如果输出为1则修改脚本让它输出为2，然后验证修改
```

**不好的描述**：
```
处理 test.sh
```

### 2. 指定条件和预期结果

**好的描述**：
```
检查 config.json 中的 debug 字段，如果为 false 则改为 true
```

**不好的描述**：
```
修改配置文件
```

### 3. 提供足够的上下文

**好的描述**：
```
在用户目录下的 test 目录中执行 a.sh，如果输出为1则修改为2
```

**不好的描述**：
```
执行 a.sh 并修改
```

### 4. 分解复杂任务

对于非常复杂的任务，可以分成多个自适应执行：

```bash
# 第一步：分析
python main.py --adaptive -c "分析 data.csv 的结构和内容"

# 第二步：处理
python main.py --adaptive -c "根据 data.csv 的结构，计算统计信息"

# 第三步：报告
python main.py --adaptive -c "生成分析报告"
```

## 限制和注意事项

### 1. 最大迭代次数

默认最大迭代次数为 50 次，防止无限循环。如果任务未完成，会显示警告。

### 2. 命令安全

- 保持现有的白名单机制
- 危险命令需要用户确认
- 建议在测试环境先试用

### 3. 输出长度

- 每步输出限制在 500 字符（显示）
- 完整输出会传递给 AI
- 历史记录保留最近 10 步

### 4. SSH 模式

- SSH 模式下所有命令在远程执行
- 文件路径相对于远程主机
- 确保有足够的权限

## 故障排查

### 问题 1：AI 生成的步骤不合理

**原因**：任务描述不够清晰或上下文不足

**解决**：
- 提供更详细的任务描述
- 指定文件路径和预期结果
- 分解复杂任务

### 问题 2：任务未完成就停止

**原因**：AI 认为任务已完成或达到最大迭代次数

**解决**：
- 检查任务描述是否明确
- 查看执行历史，了解停止原因
- 手动完成剩余步骤

### 问题 3：命令执行失败

**原因**：权限不足、文件不存在等

**解决**：
- 检查文件路径和权限
- 查看错误信息
- AI 会根据错误调整策略

### 问题 4：输出过长导致性能问题

**原因**：某些命令输出大量内容

**解决**：
- 使用 `head`、`tail` 限制输出
- 使用 `grep` 过滤内容
- 将结果保存到文件而不是输出

## 与传统模式对比

| 特性 | 传统模式 | 自适应模式 |
|------|----------|------------|
| 执行方式 | 一次性生成所有步骤 | 渐进式生成 |
| 反馈循环 | 无 | 有 |
| 条件判断 | 不支持 | 支持 |
| 错误恢复 | 重新生成整个计划 | 局部调整 |
| 适用场景 | 简单、确定的任务 | 复杂、需要判断的任务 |
| LLM 调用次数 | 1次 | 多次（根据迭代次数） |

## 性能考虑

### LLM 调用成本

- 每次迭代调用一次 LLM
- 复杂任务可能需要 5-10 次迭代
- 建议先用简单任务测试

### 优化建议

1. **批量生成步骤**：每次生成 2-3 个步骤而不是 1 个
2. **清晰的任务描述**：减少不必要的迭代
3. **使用传统模式**：对于简单任务使用传统模式

## 高级用法

### 1. 组合使用

```bash
# 先用传统模式快速执行简单任务
python main.py -c "创建测试目录"

# 再用自适应模式处理复杂任务
python main.py --adaptive -c "分析目录中的所有日志文件"
```

### 2. 脚本化

```bash
#!/bin/bash
# 自动化脚本

# 检查环境
python main.py --adaptive -c "检查系统环境和依赖"

# 执行任务
python main.py --adaptive -c "根据配置文件执行相应操作"

# 生成报告
python main.py --adaptive -c "生成执行报告"
```

### 3. 调试模式

查看详细的执行过程：

```bash
# 执行后查看完整历史
python main.py --adaptive -c "你的任务" 2>&1 | tee execution.log
```

## 示例脚本

### 创建测试脚本

```bash
# 创建测试脚本 a.sh
cat > ~/test/a.sh << 'EOF'
#!/bin/bash
echo 1
EOF

chmod +x ~/test/a.sh
```

### 测试自适应模式

```bash
# 测试修改脚本
python main.py --adaptive -c "执行 ~/test/a.sh，如果输出为1则修改为2"

# 验证结果
bash ~/test/a.sh
# 应该输出: 2
```

## 总结

自适应执行模式是 AutoShell 的强大功能，适合：

✅ 需要根据输出做决策的任务
✅ 包含条件判断的复杂任务
✅ 需要多步骤协调的任务
✅ 文件内容分析和处理

不适合：

❌ 简单的单步命令
❌ 已知确定步骤的任务
❌ 对性能要求极高的场景

根据任务特点选择合适的模式，可以获得最佳体验。

---

**文档版本**：v1.0
**最后更新**：2026-01-21
